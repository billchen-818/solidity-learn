# solidity源文件布局

源文件可以包含任意数量的合约定义、导入指令、pragma指令和结构、枚举、函数、错误和常量变量定义。

## SPDX许可证标识符

如果他们的源代码可用，则可以更好地建立对智能合约的信任。由于提供源代码总是会涉及版权方面的法律问题，因此 Solidity 编译器鼓励使用机器可读的 SPDX 许可证标识符。每个源文件都应以指示其许可证的注释开头：

```
// SPDX-License-Identifier: MIT
```

编译器不会验证许可证是否是 SPDX 允许的列表的一部分，但会在字节码元数据中包含提供的字符串。

如果您不想指定许可证或源代码不是开源的，请使用特殊值 UNLICENSED。

当然，提供此评论并不能免除您与许可相关的其他义务，例如必须在每个源文件或原始版权所有者中提及特定的许可标头。

编译器可以在文件级别的文件中的任何位置识别注释，但建议将其放在文件的顶部。

有关如何使用 SPDX 许可证标识符的更多信息，请访问 SPDX 网站。

## 编译指示

pragma关键字用于启用某些编译器功能或检查。pragma指令始终位于源文件本地(在源文件里面),所以如果要在整个项目中启用它，则必须将pragma添加到所有文件中。如果导入另一个文件，则该文件中的编译指示不会自动应用于导入文件。

### Version Pragma(版本编译指示)

源文件可以并且应该使用版本编译指示进行注释，以拒绝使用可能引入不兼容更改的未来编译器版本进行编译。我们试图将这些保持在绝对最低限度，并以语义变化也需要语法变化的方式引入它们，但这并不总是可行的。因此，至少对于包含重大更改的版本，通读更改日志总是一个好主意。这些版本始终具有 0.x.0 或 x.0.0 形式的版本。

版本 pragma 使用如下：pragma solidity ^0.5.2;

带有上一行的源文件不能用早于 0.5.2 版本的编译器编译，它也不能在 0.6.0 版本开始的编译器上工作（第二个条件是通过使用 ^ 添加的）。因为在 0.6.0 版本之前不会有重大更改，所以您可以确保您的代码按照您预期的方式编译。编译器的确切版本未固定，因此仍然可以发布错误修复版本。

可以为编译器版本指定更复杂的规则，这些规则与 npm 使用的语法相同。

使用 version pragma 不会更改编译器的版本。它也不启用或禁用编译器的功能。它只是指示编译器检查其版本是否与编译指示所需的版本匹配。如果不匹配，编译器会发出错误。


### ABI 编码器编译指示

通过使用 pragma abicoder v1 或 pragma abicoder v2，您可以在 ABI 编码器和解码器的两种实现之间进行选择。

新的 ABI 编码器 (v2) 能够对任意嵌套的数组和结构进行编码和解码。它可能会产生不太理想的代码，并且没有像旧编码器那样接受那么多的测试，但从 Solidity 0.6.0 开始，它被认为是非实验性的。您仍然必须使用 pragma abicoder v2; 显式激活它。由于它将默认从 Solidity 0.8.0 开始激活，因此可以选择使用 pragma abicoder v1; 选择旧编码器。

新编码器支持的类型集是旧编码器支持的类型的严格超集。使用它的合约可以与没有限制的合约进行交互。只有当非 abcoder v2 合约不尝试进行需要新编码器仅支持的解码类型的调用时，反向才是可能的。编译器可以检测到这一点，并会发出错误。只需为您的合约启用 abicoder v2 就足以消除错误。

此编译指示适用于激活它的文件中定义的所有代码，无论该代码最终在哪里结束。这意味着选择使用 ABI 编码器 v1 编译源文件的合约仍然可以包含通过从另一个合约继承新编码器的代码。如果新类型仅在内部使用而不是在外部函数签名中使用，则这是允许的。

在 Solidity 0.7.4 之前，可以使用 pragma Experimental ABIEncoderV2 选择 ABI 编码器 v2，但无法明确选择编码器 v1，因为它是默认设置。

### 实验语用

第二个 pragma 是实验 pragma。它可用于启用默认情况下尚未启用的编译器或语言的功能。目前支持以下实验性编译指示：

**ABIEncoderV2**

因为 ABI 编码器 v2 不再被认为是实验性的，它可以从 Solidity 0.7.4 开始通过 pragma abicoder v2（请参见上文）选择。

**贴片检查器**

在构建 Solidity 编译器时必须启用此组件，因此它并非在所有 Solidity 二进制文件中都可用。构建说明解释了如何激活此选项。它在大多数版本中为 Ubuntu PPA 版本激活，但不适用于 Docker 映像、Windows 二进制文件或静态构建的 Linux 二进制文件。如果您在本地安装了 SMT 求解器并通过节点（而不是通过浏览器）运行 solc-js，则可以通过 smtCallback 为 solc-js 激活它。

如果您使用 pragma Experimental SMTChecker;，那么您将获得额外的安全警告，这些警告是通过查询 SMT 求解器获得的。该组件尚不支持 Solidity 语言的所有功能，并且可能会输出许多警告。如果它报告不受支持的功能，分析可能不完全正确。

## 导入其他源文件


### 语法与语义

solidity支持import语句来帮助模块化您的代码，这些代码类似于JavaScript中可用的代码。但是solidity不支持导出的概念。

在全局级别，您可以使用以下形式的导入语句：

```
import "filename";
```

文件名部分称为导入路径。该语句将所有全局符号从“文件名”（以及在那里导入的符号）导入到当前的全局作用域中（与 ES6 不同，但向后兼容 Solidity）。不推荐使用这种形式，因为它不可预测地污染了命名空间。如果您在“文件名”中添加新的顶级项目，它们会自动出现在所有像这样从“文件名”导入的文件中。最好明确导入特定符号。

以下示例创建一个新的全局符号 symbolName，其成员是“filename”中的所有全局符号：

```
import * as symbolName from "filename";
```

这导致所有全局符号都以 symbolName.symbol 格式提供。

这种语法的一个变体不是 ES6 的一部分，但可能有用的是：

导入“文件名”作为符号名；

```
import * as symbolName from "filename";。
```

如果存在命名冲突，您可以在导入时重命名符号。例如，下面的代码创建了新的全局符号别名和符号 2，它们分别从“文件名”内部引用了符号 1 和符号 2。

从“文件名”导入 {symbol1 作为别名，symbol2}；
导入路径
为了能够在所有平台上支持可重现的构建，Solidity 编译器必须抽象出存储源文件的文件系统的细节。因此，导入路径不直接引用主机文件系统中的文件。相反，编译器维护一个内部数据库（虚拟文件系统或简称 VFS），其中每个源单元都被分配了一个唯一的源单元名称，该名称是一个不透明和非结构化的标识符。导入语句中指定的导入路径被翻译成源单元名称，用于在该数据库中查找对应的源单元。

使用标准 JSON API，可以直接提供所有源文件的名称和内容作为编译器输入的一部分。在这种情况下，源单元名称确实是任意的。但是，如果您希望编译器自动查找源代码并将其加载到 VFS 中，那么您的源单元名称的结构需要使导入回调能够定位它们。使用命令行编译器时，默认导入回调仅支持从主机文件系统加载源代码，这意味着您的源单元名称必须是路径。某些环境提供更通用的自定义回调。例如，Remix IDE 提供了一种允许您从 HTTP、IPFS 和 Swarm URL 导入文件或直接引用 NPM 注册表中的包。

有关虚拟文件系统和编译器使用的路径解析逻辑的完整描述，请参阅路径解析。

## 注释

- 单行注释(//) 
- 多行注释(/**/)